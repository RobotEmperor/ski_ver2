#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <unistd.h>
#include <sched.h>
#include <string.h>
#include <sys/time.h>
#include <time.h>
#include <pthread.h>
#include <math.h>
#include <inttypes.h>
#include <ros/ros.h>

#include "diana_msgs/ForceTorque.h"
#include "ethercat.h"

#define EC_TIMEOUTMON 500
#define NSEC_PER_SEC 1000000000

void SendCommand(uint8_t *data, uint16_t *buf, int buf_length);
void PrintValues(uint8_t *data);
void GetSensorValue(double new_data[6], uint8_t *data);
void SetRosMsg(diana_msgs::ForceTorque *ft_msg, double *data);
double Kalman(double *input, double *data, int length);
OSAL_THREAD_FUNC ec_check(void *ptr);

struct sched_param schedp;
char IOmap[4096];
pthread_t thread1;
struct timeval tv, t1, t2;
int dorun = 0;
int deltat, tmax = 0;
int64 toff;
int DCdiff;
int os;
uint8 ob;
uint16 ob2;
pthread_cond_t      cond  = PTHREAD_COND_INITIALIZER;
pthread_mutex_t     mutex = PTHREAD_MUTEX_INITIALIZER;
uint8 *digout = 0;
int wcounter;
ros::Publisher ec_data;// = nh.advertise<diana_msgs::ForceTorque>("/diana/force_torque_data", 0);
bool needlf;

void redtest(char *ifname, char *ifname2)
{
  int cnt, i, j, oloop, iloop;
  
  needlf = FALSE;

  int storage_size = 500;
  double data_storage[2][6][storage_size];

  diana_msgs::ForceTorque msg;

  for(int i=0 ; i<6 ; i++)
    for(int j=0 ; j<storage_size ; j++)
    {
      data_storage[0][i][j] = 0;
      data_storage[1][i][j] = 0;
    }

  printf("Starting Redundant test\n");

  /* initialise SOEM, bind socket to ifname */
  if (ec_init_redundant(ifname, ifname2))
  {
    printf("ec_init on %s succeeded.\n",ifname);
    /* find and auto-config slaves */
    if ( ec_config(FALSE, &IOmap) > 0 )
    {
      printf("%d slaves found and configured.\n",ec_slavecount);
      /* wait for all slaves to reach SAFE_OP state */
      ec_statecheck(0, EC_STATE_SAFE_OP,  EC_TIMEOUTSTATE);

      /* configure DC options for every DC capable slave found in the list */
      ec_configdc();

      /* read indevidual slave state and store in ec_slave[] */
      ec_readstate();
      for(cnt = 1; cnt <= ec_slavecount ; cnt++)
      {
        printf("Slave:%d Name:%s Output size:%3dbits Input size:%3dbits State:%2d delay:%d.%d\n",
            cnt, ec_slave[cnt].name, ec_slave[cnt].Obits, ec_slave[cnt].Ibits,
            ec_slave[cnt].state, (int)ec_slave[cnt].pdelay, ec_slave[cnt].hasdc);
        printf("         Out:%8.8x,%4d In:%8.8x,%4d\n",
            (int)*ec_slave[cnt].outputs, ec_slave[cnt].Obytes, (int)*ec_slave[cnt].inputs, ec_slave[cnt].Ibytes);
        /* check for EL2004 or EL2008 */
        if( !digout && ((ec_slave[cnt].eep_id == 0x07d43052) || (ec_slave[cnt].eep_id == 0x07d83052)))
        {
          digout = ec_slave[cnt].outputs;
        }
      }
      printf("Request operational state for all slaves\n");
      ec_slave[0].state = EC_STATE_OPERATIONAL;
      /* request OP state for all slaves */
      ec_writestate(0);
      /* wait for all slaves to reach OP state */
      ec_statecheck(0, EC_STATE_OPERATIONAL,  EC_TIMEOUTSTATE);
      oloop = ec_slave[0].Obytes;
      if ((oloop == 0) && (ec_slave[0].Obits > 0)) oloop = 1;
      if (oloop > 8) oloop = 8;
      iloop = ec_slave[0].Ibytes;
      if ((iloop == 0) && (ec_slave[0].Ibits > 0)) iloop = 1;
      if (iloop > 8) iloop = 8;
      if (ec_slave[0].state == EC_STATE_OPERATIONAL )
      {
        printf("Operational state reached for all slaves.\n");
        dorun = 1;
        
        ec_send_processdata();
        ec_receive_processdata(EC_TIMEOUTRET);
        printf("slave count : %d\n", ec_slavecount);
        //int wkc = ec_receive_processdata(EC_TIMEOUTRET);

        for(int n=0 ; n<ec_slavecount ; n++)
        {
          //printf("%d \n", wkc);
          if(!needlf)
          {
            uint16_t buf[4];
            int buf_size = 4;

            //set cutoff frequency to 150Hz
            buf[0] = 0x00;
            buf[1] = 0x04;
            buf[2] = 0x01;
            buf[3] = 0x08;
            SendCommand(ec_slave[n].outputs, buf, buf_size);

            //start command
            buf[0] = 0x00;
            buf[1] = 0x00;
            buf[2] = 0x00;
            buf[3] = 0x0B;
            SendCommand(ec_slave[n].outputs, buf, buf_size);

            if(n+1 == ec_slavecount)
              needlf = TRUE;
          }

          //PrintValues(ec_slave[0].inputs);
          double data[6];
          GetSensorValue(data, ec_slave[n].inputs);

          for(int i=0 ; i<6 ; i++)
          {
            Kalman(data+i, data_storage[n][i], storage_size);
          }

          printf("\n");
          printf("Force  : Fx= %10.2f, Fy= %10.2f, Fz= %10.2f \n",
              data[0], data[1], data[2]);
          printf("Torque : Tx= %10.2f, Ty= %10.2f, Tz= %10.2f \n",
              data[3], data[4], data[5]);

          SetRosMsg(&msg, data);

          ec_data.publish(msg);
        }
        osal_usleep(10);
        
        dorun = 0;
      }
      else
      {
        printf("Not all slaves reached operational state.\n");
      }
      printf("Request safe operational state for all slaves\n");
      ec_slave[0].state = EC_STATE_SAFE_OP;
      /* request SAFE_OP state for all slaves */
      ec_writestate(0);
    }
    else
    {
      printf("No slaves found!\n");
    }
    printf("End redundant test, close socket\n");
    /* stop SOEM, close socket */
    ec_close();
  }
  else
  {
    printf("No socket connection on %s\nExcecute as root\n",ifname);
  }
}

/* add ns to timespec */
void add_timespec(struct timespec *ts, int64 addtime)
{
  int64 sec, nsec;

  nsec = addtime % NSEC_PER_SEC;
  sec = (addtime - nsec) / NSEC_PER_SEC;
  ts->tv_sec += sec;
  ts->tv_nsec += nsec;
  if ( ts->tv_nsec > NSEC_PER_SEC )
  {
    nsec = ts->tv_nsec % NSEC_PER_SEC;
    ts->tv_sec += (ts->tv_nsec - nsec) / NSEC_PER_SEC;
    ts->tv_nsec = nsec;
  }
}

/* PI calculation to get linux time synced to DC time */
void ec_sync(int64 reftime, int64 cycletime , int64 *offsettime)
{
  static int64 integral = 0;
  int64 delta;
  /* set linux sync point 50us later than DC sync, just as example */
  delta = (reftime - 50000) % cycletime;
  if(delta> (cycletime / 2)) { delta= delta - cycletime; }
  if(delta>0){ integral++; }
  if(delta<0){ integral--; }
  *offsettime = -(delta / 100) - (integral / 20);
}

/* RT EtherCAT thread */
void* ecatthread( void *ptr )
{
  struct timespec   ts;
  struct timeval    tp;
  int rc;
  int ht;
  int64 cycletime;

  rc = pthread_mutex_lock(&mutex);
  rc =  gettimeofday(&tp, NULL);

  /* Convert from timeval to timespec */
  ts.tv_sec  = tp.tv_sec;
  ht = (tp.tv_usec / 1000) + 1; /* round to nearest ms */
  ts.tv_nsec = ht * 1000000;
  cycletime = *(int*)ptr * 1000; /* cycletime in ns */
  toff = 0;
  dorun = 0;
  while(1)
  {
    /* calculate next cycle start */
    add_timespec(&ts, cycletime + toff);
    /* wait to cycle start */
    rc = pthread_cond_timedwait(&cond, &mutex, &ts);
    if (dorun>0)
    {
      rc =  gettimeofday(&tp, NULL);

      ec_send_processdata();

      wcounter = ec_receive_processdata(EC_TIMEOUTRET);

      dorun++;
      /* if we have some digital output, cycle */
      if( digout ) *digout = (uint8) ((dorun / 16) & 0xff);

      if (ec_slave[0].hasdc)
      {
        /* calulate toff to get linux time and DC synced */
        ec_sync(ec_DCtime, cycletime, &toff);
      }
    }
  }
}

int main(int argc, char *argv[])
{
  int iret1;
  int ctime;
  struct sched_param    param;
  int                   policy = SCHED_OTHER;
  char left_name[] = "eth1";
  char right_name[] = "eth0";
  
  ros::init(argc, argv, "ec_node");
  ros::NodeHandle nh;
  ec_data = nh.advertise<diana_msgs::ForceTorque>("/diana/force_torque_data", 0);
  
  printf("SOEM (Simple Open EtherCAT Master)\nRedundancy test\n");

  memset(&schedp, 0, sizeof(schedp));
  /* do not set priority above 49, otherwise sockets are starved */
  schedp.sched_priority = 30;
  sched_setscheduler(0, SCHED_FIFO, &schedp);

  do
  {
    usleep(1000);
  }
  while (dorun);

  dorun = 1;
  ctime = 500;
  /* create RT thread */
  iret1 = pthread_create( &thread1, NULL, ecatthread, (void*)&ctime);
  memset(&param, 0, sizeof(param));
  /* give it higher priority */
  param.sched_priority = 40;
  iret1 = pthread_setschedparam(thread1, policy, &param);

  /* start acyclic part */
  redtest(left_name, right_name);
 
  ros::spin();

  schedp.sched_priority = 0;
  sched_setscheduler(0, SCHED_OTHER, &schedp);

  printf("End program\n");

  return (0);
}

//------------------------------------------------------------
/*
int main(int argc, char *argv[])
{
  char left_name[] = "eth1";
  char right_name[] = "eth0";
  int oloop, iloop, chk;
  inOP = FALSE;
  if(ec_init_redundant(left_name, right_name))
  {
    printf("init success.\n");
    if(ec_config(FALSE, &IOmap) > 0)
    {
      printf("slave count : %d\n", ec_slavecount);
      //ec_config_map(&IOmap);
      ec_configdc();
      ec_readstate();

      for(int i=1; i<=ec_slavecount ; i++)
      {
        printf("Slave:%d Name:%s Output size:%3dbits Input size:%3dbits State:%2d delay:%d.%d\n",
            i, ec_slave[i].name, ec_slave[i].Obits, ec_slave[i].Ibits,
            ec_slave[i].state, (int)ec_slave[i].pdelay, ec_slave[i].hasdc);
        printf("         Out:%8.8x,%4d In:%8.8x,%4d\n",
            (int)*ec_slave[i].outputs, ec_slave[i].Obytes, (int)*ec_slave[i].inputs, ec_slave[i].Ibytes);
      }

      ec_slave[0].state = EC_STATE_OPERATIONAL;
      ec_slave[1].state = EC_STATE_OPERATIONAL;
      ec_writestate(0);
      ec_writestate(1);
      ec_statecheck(0, EC_STATE_SAFE_OP, EC_TIMEOUTSTATE * 4);
      ec_statecheck(1, EC_STATE_SAFE_OP, EC_TIMEOUTSTATE * 4);

      // get count of outloop and inloops
      oloop = ec_slave[0].Obytes;
      iloop = ec_slave[0].Ibytes;

      if((oloop == 0) && (ec_slave[0].Obits > 0))
        oloop = 1;
      if((iloop == 0) && (ec_slave[0].Ibits > 0))
        iloop = 1;

      // get expected wkc(working count) = (output wkc * 2) + intput wkc
      expected_wkc = (ec_group[0].outputsWKC *2 ) + ec_group[0].inputsWKC;

      //ec_slave[0].state = EC_STATE_OPERATIONAL;

      ec_send_processdata();
      ec_receive_processdata(EC_TIMEOUTRET);
      //ec_writestate(0);

      chk = 40;
      do
      {
        ec_send_processdata();
        ec_receive_processdata(EC_TIMEOUTRET);
        ec_statecheck(0, EC_STATE_OPERATIONAL, 50000);
        ec_statecheck(1, EC_STATE_OPERATIONAL, 50000);
      }
      while(chk-- && ec_slave[0].state != EC_STATE_OPERATIONAL && 
          chk-- && ec_slave[1].state != EC_STATE_OPERATIONAL);



      while(ec_slave[0].state == EC_STATE_OPERATIONAL && ros::ok())
      {
        //printf("hihihihihihihihihihi\n");
        // update ethercat slave....
        ec_send_processdata();
        ec_receive_processdata(EC_TIMEOUTRET);
        printf("slave count : %d\n", ec_slavecount);
        //int wkc = ec_receive_processdata(EC_TIMEOUTRET);

        for(int n=0 ; n<ec_slavecount ; n++)
        {
          //printf("%d \n", wkc);
          if(!needlf)
          {
            uint16_t buf[4];
            int buf_size = 4;

            //set cutoff frequency to 150Hz
            buf[0] = 0x00;
            buf[1] = 0x04;
            buf[2] = 0x01;
            buf[3] = 0x08;
            SendCommand(ec_slave[n].outputs, buf, buf_size);

            //start command
            buf[0] = 0x00;
            buf[1] = 0x00;
            buf[2] = 0x00;
            buf[3] = 0x0B;
            SendCommand(ec_slave[n].outputs, buf, buf_size);

            if(n+1 == ec_slavecount)
              needlf = TRUE;
          }

          //PrintValues(ec_slave[0].inputs);
          double data[6];
          GetSensorValue(data, ec_slave[n].inputs);

          for(int i=0 ; i<6 ; i++)
          {
            Kalman(data+i, data_storage[n][i], storage_size);
          }

          printf("\n");
          printf("Force  : Fx= %10.2f, Fy= %10.2f, Fz= %10.2f \n",
              data[0], data[1], data[2]);
          printf("Torque : Tx= %10.2f, Ty= %10.2f, Tz= %10.2f \n",
              data[3], data[4], data[5]);

          SetRosMsg(&msg, data);

          ec_data.publish(msg);
          ros::spinOnce();
        }
        osal_usleep(10);
      }



      inOP = FALSE;

      printf("Not all slaves reached operational state.\n");
      ec_readstate();
      for(int i = 1; i<=ec_slavecount ; i++)
      {
        if(ec_slave[i].state != EC_STATE_OPERATIONAL)
        {
          printf("Slave %d State=0x%2.2x StatusCode=0x%4.4x : %s\n",
              i, ec_slave[i].state, ec_slave[i].ALstatuscode, ec_ALstatuscode2string(ec_slave[i].ALstatuscode));
        }
      }
      printf("\nRequest init state for all slaves\n");
      ec_slave[0].state = EC_STATE_INIT;
      // request INIT state for all slaves 
      ec_writestate(0);
    }
    else
    {
      printf("No slaves found!\n");
    }
    ec_close();
  }
  else
  {
    printf("No socket connection on %s\nExcecute as root\n",left_name);
  }
}

*/

void SendCommand(uint8_t *data, uint16_t *buf, int buf_length)
{
  for(int i=0 ; i<buf_length ; i++)
  {
    *data++ = (buf[buf_length-i-1] >> 0) & 0xFF;
    *data++ = (buf[buf_length-i-1] >> 8) & 0xFF;
  }
}

void GetSensorValue(double new_data[6], uint8_t *data)
{
  int16_t force_torque_data[6];

  // Raw_Fx, Raw_Fy, Raw_Fy (2 Bytes * 3)
  force_torque_data[0] = (int16_t)(data[24] | data[25] << 8);
  force_torque_data[1] = (int16_t)(data[26] | data[27] << 8);
  force_torque_data[2] = (int16_t)(data[28] | data[29] << 8);

  // Raw_Tx, Raw_Ty, Raw_Tz (2 Bytes * 3)
  force_torque_data[3] = (int16_t)(data[30] | data[31] << 8);
  force_torque_data[4] = (int16_t)(data[32] | data[33] << 8);
  force_torque_data[5] = (int16_t)(data[34] | data[35] << 8);

  double force_divider = 50;
  double torque_divider = 2000;

  for(int i=0 ; i<3 ; i++)
  {
    new_data[i] = (double)force_torque_data[i]/force_divider;
    new_data[i+3] = (double)force_torque_data[i+3]/torque_divider;
  }


  //printf("\n");
  //printf("Raw_Force  : Fx= %10.2f, Fy= %10.2f, Fz= %10.2f \n",
  //force[0], force[1], force[2]);
  //printf("Raw_Torque : Tx= %10.2f, Ty= %10.2f, Tz= %10.2f \n",
  //torque[0], torque[1], torque[2]);

}

void SetRosMsg(diana_msgs::ForceTorque *ft_msg, double *data)
{
  ft_msg->force_x_raw_l = data[0];
  ft_msg->force_y_raw_l = data[1];
  ft_msg->force_z_raw_l = data[2];
  ft_msg->torque_x_raw_l = data[3];
  ft_msg->torque_y_raw_l = data[4];
  ft_msg->torque_z_raw_l = data[5];
}

double Kalman(double *input, double *data, int length)
{
  double result = (*input / length);

  for(int i=1 ; i<length ; i++)
  {
    result += (data[i] / length);
    data[i-1] = data[i];
  }
  data[length-1] = *input;

  *input = result;
  return result;
}

void PrintValues(uint8_t *data)
{
  // CanRx1_id (2 Bytes)
  uint16_t can_rx1_id = *data | (*(data+1) >> 8);
  data += 2;

  // CanRx1_len (2 Bytes)
  uint16_t can_rx1_len = *data | (*(data+1) >> 8);
  data += 2;

  // CanRx1_data_d1 ~ d8 (1 Byte * 8)
  uint8_t can_rx1_data[8];
  for(int i=0 ; i<8 ; i++)
    can_rx1_data[i] = *data++;

  // CanRx2_id (2 Bytes)
  uint16_t can_rx2_id = *data | (*(data+1) >> 8);
  data += 2;

  // CanRx2_len (2 Bytes)
  uint16_t can_rx2_len = *data | (*(data+1) >> 8);
  data += 2;

  // CanRx2_data_d1 ~ d8 (1 Byte * 8)
  uint8_t can_rx2_data[8];
  for(int i=0 ; i<8 ; i++)
    can_rx2_data[i] = *data++;

  int16_t raw_force[3];
  // Raw_Fx (2 Bytes)
  raw_force[0] = (int16_t)(*data | (*(data+1) >> 8));
  data += 2;
  // Raw_Fy (2 Bytes)
  raw_force[1] = (int16_t)(*data | (*(data+1) >> 8));
  data += 2;
  // Raw_Fz (2 Bytes)
  raw_force[2] = (int16_t)(*data | (*(data+1) >> 8));
  data += 2;

  int16_t raw_torque[3];
  // Raw_Tx (2 Bytes)
  raw_torque[0] = (int16_t)(*data | (*(data+1) >> 8));
  data += 2;
  // Raw_Ty (2 Bytes)
  raw_torque[1] = (int16_t)(*data | (*(data+1) >> 8));
  data += 2;
  // Raw_Tz (2 Bytes)
  raw_torque[2] = (int16_t)(*data | (*(data+1) >> 8));
  data += 2;

  // OverloadStatus (1 Byte)
  uint8_t overload_status = *data++;

  // ErrorFlag (1 Byte)
  uint8_t error_flag = *data++;

  printf("CanRx1_id  : %d \n", can_rx1_id);
  printf("CanRx1_len : %d \n", can_rx1_len);
  printf("CanRx1_data_d1~d8 : ");
  for(int i=0 ; i<8 ; i++)
    printf("%3d ", can_rx1_data[i]);
  printf("\n");
  printf("CanRx2_id  : %d \n", can_rx2_id);
  printf("CanRx2_len : %d \n", can_rx2_len);
  printf("CanRx2_data_d1~d8 : ");
  for(int i=0 ; i<8 ; i++)
    printf("%3d ", can_rx2_data[i]);
  printf("\n");
  printf("Raw_Force  : Fx= %4d, Fy= %4d, Fz= %4d \n", raw_force[0], raw_force[1], raw_force[2]);
  printf("Raw_Torque : Tx= %4d, Ty= %4d, Tz= %4d \n", raw_torque[0], raw_torque[1], raw_torque[2]);
  printf("OverloadStatus : %2d \n", overload_status);
  printf("ErrorFlag  : %2d \n\n\n", error_flag);
}




